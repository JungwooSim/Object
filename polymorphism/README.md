# 12. 다형성

> 이번 장에서는 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘을 살펴본다.</br>
> 이번 장을 읽고 나면 다형성이 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현되며, 상속이 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이라는 사실을 이해할 수 있다.

### 01. 다형성

다형성(Polymorphism) 이라는 단어는 그리스어에서 '많은'을 의미하는 'poly'와 '형태'를 의미하는 'morph' 의 합성어로 '많은 형태를 가질 수 있는 능력'을 의미한다.</br>
컴퓨터 과학에서는 다형성을 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의한다.</br>
간단하게 말해서 다형성은 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이라고 할 수 있다.</br>
객체지향 프로그래밍에서 사용되는 다형성은 [그림12.1]과 같이 유니버셜(Universal) 다형성과 임시(Ad Hoc) 다형성으로 분류할 수 있다.</br>
유니버셜 다형성은 매게변수(Parametric) 다형성과 포함(Inclustion) 다형성으로 분류할 수 있고, 임시 다형성은 오버로딩(Overloading) 다형성과 강제(Coercion) 다형성으로 분류할 수 있다.</br>

<img src="/polymorphism/img/12-1.png" width="500px;" />

하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우를 가리켜 오버로딩 다형성이라고 부른다.

**매게변수 다형성**은 **제네릭 프로그래밍**과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매게변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에서 구체적인 타입으로 지정하는 방식을 가리킨다.</br>
예를 들어, 자바의 List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며 실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할 수 있게 하고 있다.</br>
**포함 다형성**은 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미한다.</br>
포함 다형성은 **서브타입(Subtype) 다형성**이라고도 부른다.</br>
포함 다형성은 객체지향 프로그래밍에서 가장 널리 알려진 형태의 다형성이기 때문에 특별한 언급 없이 다형성이라고 할 때는 포함 다형성을 의미하는 것이 일반적이다.</br>
```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.</br>

### 02. 상속의 양면성

상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하는 것이다.</br>
상속의 메커니즘을 이해하는 데 필요한 몇가지 개념을 살펴보자면,</br>

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조

**데이터 관점의 상속**

데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.</br>
따라서 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 된다.</br>

**행동 관점의 상속**

부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.

### 03. 업캐스팅과 동적 바인딩

**같은 메시지, 다른 메서드**

메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩이라는 매커니즘이 작용하기 때문이다.

- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 **업캐스팅**이라고 부른다.
- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.</br>
  이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다.</br>
  이를 **동적 바인딩**이라 부른다.

**업캐스팅**

```java
Lecture lecture = new GradeLecture(); // 부모 클래스에 자식 인스턴스를 할당 (업캐스팅)
GradeLecture GradeLecture = (GradeLecture)lecture; // 자식 클래스에 부모 인스턴스 할당(다운캐스팅)
```

부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요한데 이를 다운캐스팅(downcasting)이라고 부른다.

<img src="/polymorphism/img/12-7.png" width="500px;" />

컴파일러 관점에서 자식 클래스는 아무런 제약 없이 부모 클래스를 대체할 수 있기 때문에 부모 클래스와 협력하는 클라이언트는 다양한 자식 클래스의 인스턴스와도 협력하는 것이 가능하다. 따라서 이 설계는 유연하며 확장이 용이하다.

<img src="/polymorphism/img/12-8.png" width="500px;" />

**동적 바인딩**

컴파일타임에 호출할 함수를 결정하는 방식을 **정적 바인딩(static binding)**, **초기 바인딩(early binding)** , 또는 **컴파일타임 바인딩(compile-time binding)** 이라고 부른다.</br>
객체지향 언어에서는 메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다.</br>
실행될 메서드를 런타임에 결정하는 방식을 **동적 바인딩(dynamic binding)** 또는 **지연 바인딩(late binding)** 이라고 부른다.</br>

### 04. 동적 메서드 탐색과 다형성

객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다.

- 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 메서드를 실행하고 탐색을 종료한다.
- 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속한다. 이 과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계손된다.
- 상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 종료한다.

<img src="/polymorphism/img/12-9.png" width="500px;" />

메서드 탐색은 자식 클래스에서 부모 클래스 방향으로 진행된다. 따라서 항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 먼저 탐색되기 때문에 자식 클래스에 선언된 메서드가 부모 클래스의 메서드보다 우선순위를 가지게 된다.

동적 메서드 탐색은 두가지 원리로 구성된다.

1. 자동적인 메시지 위임
    - 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임한다.</br>
      클래스 사이의 위임은 프로그래머의 개입 없이 상속 계층을 따라 자동으로 이뤄진다.
2. 메서드를 탐색하기 위해 **동적인 문맥**을 사용
    - 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.

**이해할 수 없는 메시지**

**정적 타입 언어와 이해할 수 없는 메시지**

정적 타입 언어에서는 코드를 컴파일할 때 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.</br>
따라서 상속 계층 전체를 탐색한 후에도 메시지를 처리할 수 있는 메서드를 발견하지 못했다면 컴파일 에러가 발생한다.</br>
예를 들어 정적 타입 자바에서 Lecture 의 인스턴스가 이해할 수 없는 unknownMessage 메시지를 전송했다고 가정해보자.</br>

```java
Lecture lecture = new GradeLecture();
lecture.unknownMessage(); // 컴파일 에러
```

**동적 타입 언어와 이해할 수 없는 메시지**

동적 타입 언어 역시 메시지를 수신한 객체의 클래스로부터 부모 클래스의 방향으로 메서드를 탐색한다.</br>
차이점이라면 동적 타입 언어에는 컴파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단할 수 없다는 점이다.</br>

<img src="/polymorphism/img/12-18.png" width="500px;" />

**self 대 super**

self 참조의 가장 큰 특징은 동적이라는 점이다.</br>
self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다. 이런 특성과 대비해서 언급할 만한 가치가 있는 것이 **super 참조(super reference)**다.</br>

<img src="/polymorphism/img/12-19.png" width="500px;" />

super 참조의 정확한 의도는 '지금 이 클래스의 부모 클래스에서부터 메서드를 탐색을 시작하세요'다. 만약 부모 클래스에서 원하는 메서드를 찾지 못한다면 더 상위의 부모 클래스로 이동하면서 메서드가 존재하는지 검사한다.</br>
super 참조를 통해 메시지를 전송하는 것은 마치 부모 클래스의 인스턴스에게 메시지를 전송하는 것처럼 보이기 때문에 이를 super 전송(super send)이라고 부른다.</br>
self 전송이 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정하는데 비해 super 전송은 항상 메시지를 전송하는 클래스의 부모 클래스에서 부터 시작된다. 따라서 self 전송의 경우 메서드 탐색을 시작할 클래스를 반드시 실행 시점에 동적으로 결정해야 하지만 super 전송의 경우에는 컴파일 시점에 미리 결정해 놓을 수 있다.</br>

동적 바인딩, self 참조, super 참조는 상속을 이용해 다형성을 구현하고 코드를 재사용하기 위한 가장 핵심적인 재료다.</br>
동적 바인딩과 self 참조는 동일한 메시지를 수신하더라도 객체의 타입에 따라 적합한 메서드를 동적으로 선택할 수 있게 한다.</br>
super 참조는 부모 클래스의 코드에 접근할 수 있게 함으로써 중복 코드를 제거할 수 있게 한다.</br>
