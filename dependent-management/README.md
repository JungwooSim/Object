# 08. 의존성 관리하기

> 충분히 협력적이면서도 유연한 객체를 만들기 위해 의존성을 관리하는 방법을 살펴 본다.

### 01. 의존성 이해하기

**변경과 의존성**

어떤 객체가 협력하기 위해 다른 객체를 필요할 때 두 객체 사이에 의존성이 존재한다.</br>
의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.</br>
- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

**의존성 전이(transitive dependency)**

<img src="/dependent-management/img/8-4.png" width="500px;" />

의존성은 전이될 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)과 간접 의존성(indirect dependency)으로 나누기도 한다.</br>
직접 의존성이란 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 말한다.</br>
간접 의존성이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 말한다.</br>

**런타임 의존성과 컴파일타임 의존성**

의존성에 대해 다뤄야하는 주제 중 런타임 의존성(run-time dependency)과 컴파일 타임 의존성(compile-time dependency) 차이가 있다.</br>
런타임 의존성은 말그대로 어플리케이션이 실행되는 시점을 가르킨다.</br>
컴파일 의존성은 작성된 코드를 컴파일하는 시점을 가르키지만 문맥에 따라서는 코드 그 자체를 가르키기도 한다.</br>

**컨텍스트 독립성**

클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해지는데, 이를 컨텍스트 독립성이라 한다.</br>
설계가 유연해지기 위해서는 가능한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.</br>

**의존성 해결하기**

컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.</br>
의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다.</br>
- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체를 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

### 02. 유연한 설계

**지식이 결합을 낮는다.**

결함도를 느슨하게 유지하려면 협력하는 대상에 대해 더 적게 알아야 한다.</br>
결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.</br>

**추상화에 의존하라**

추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.</br>
일반적으로 추상화의 결합도의 관점에서 의존 대상을 다음과 같이 구분하는 것이 유용하다.</br>
목록에서 아래쪽으로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.</br>
- 구체 클래스 의존성(concrete class dependency)
- 추상 클래스 의존성(abstract calss dependency)
- 인터페이스 의존성(interface dependency)

구체 클래스에 비해 추상 클래스는 메서드의 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다.</br>
추상 클래스의 클라이언트는 여전히 협력하는 대상이 속한 클래스 상속 계층이 무엇인지에 대해서는 알고 있어야 한다.</br>
인터페이스에 의존하면 상속 계층을 모르더라도 협력이 가능해진다.</br>
인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다.</br>
여기서 중요한 것은 실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아진다는 것이다.</br>
결합도를 느슨하게 만들기 위해서는 구체적인 클래스보다 추상 클래스에, 추상 클래스보다 인터페이스에 의존하도록 만드는 것이 더 효과적이다.</br>
다시 말해 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다는 것이다.</br>
