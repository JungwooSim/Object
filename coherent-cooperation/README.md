# 14. 일관성 있는 협력

객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다.</br>
하지만 재사용은 공짜로 얻어지지 않는다. 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.</br>
일관성 있는 협력 패턴을 적용하면 코드가 이해하기 쉽고 직관적이며 유연해진다.</br>

### 02. 설계에 일관성 부여하기

협력을 일관성 있게 만들기 위해 다음과 같은 기본 지침을 따르면 도움이 된다.

- 변하는 개념을 변하지 않는 개념으로 부터 분리
- 변하는 개념을 캡슐화

**조건 로직 대 객체 탐색**

```java
if (discountable) {
    switch(movie.getMovieType()) {
        case AMOUNT_DISCOUNT:
					// 금액 할인 정책인 경우
        case PERCENT_DISCOUNT:
					// 비율 할인 정책인 경우
        case NONE_DISCOUNT:
					// 할인 정책이 없는 경우
    }
} else {
	// 할인 적용이 불가능한 경우
}
```

절차지향 프로그램에서 변경을 처리하는 전통적인 방법은 이처럼 조건문의 분기를 추가하거나 개별 분기 로직을 수정하는 것이다.

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

객체지향은 조금 다른 접근방법을 취한다. 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동을 바꾸는 것이다.

**캡슐화 다시 살펴보기**

객체의 캡슐화에 관한 이야기를 들으면 반사적으로 데이터 은닉(data hiding)을 떠올린다.</br>
데이터 은닉이란 오직 외부에 공개된 메서드를 통해서만 객체의 내부에 접근할 수 있게 제한함으로써 객체 내부의 상태 구현을 숨기는 기법을 가리킨다.</br>
그러나 캡슐화는 데이터 은닉 이상이다.</br>
GOF의 조언에 따르면 캡슐화란 단순히 데이터를 감추는 것이 아니다.</br>
소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것이다.</br>

<img src="/coherent-cooperation/img/14-13.png" width="500px;" />

- 데이터 캡슐화
    - `Movie` 클래스의 인스턴스 변수 `title` 의 가시성은 private 이기 때문에 외부에서 직접 접근할 수 없다.</br>
      이 속성에 접근할 수 있는 유일한 방법은 메서드를 이용하는 것 뿐이다.</br>
      다시 말해 클래스는 내부에 관리하는 데이터를 캡슐화한다.
- 메서드 캡슐화
    - `DiscountPolicy` 클래스에서 정의돼 있는 `getDiscountAmount` 메서드의 가시성은 protected 다.</br>
      클래스의 외부에서는 이 메서드를 직접 접근할 수 없고 클래스 내부와 서브클래스에서만 접근이 가능하다.</br>
      따라서 클래스 외부에 영향을 미치지 않고 메서드를 수정할 수 있다.</br>
      다시 말해 클래스의 내부 행동을 캡슐화하고 있는 것이다.
- 객체 캡슐화
    - `Movie` 클래스는 `DiscountPolicy` 타입의 인스턴스 변수 `discountPolicy` 를 포함한다.</br>
      이 인스턴스 변수는 private 가시성을 가지기 때문에 `Movie` 와 `DiscountPolicy` 사이의 관계를 변경하더라도 외부에서는 영향을 미치지 않는다.</br>
      다시 말해서 객체와 객체 사이의 관계를 캡슐화 한다.</br>
      객체 캡슐화가 합성을 의미한다는 것 알 수 있다.
- 서브타입 캡슐화
    - `Movie` 는 `DiscountPolicy` 에 대해서는 알고 있지만 `AmountDiscountPolicy` 와 `PercentDiscountPolicy` 에 대해서는 알지 못한다.</br>
      그러나 실제로 실행 시점에는 이 클래스들의 인스턴스와 협력할 수 있다.</br>
      이것은 파생 클래스인 `DiscountPolicy` 와의 추상적인 관계가 `AmountDiscountPolicy` 와 `PercentDiscountPolicy` 의 존재를 감추고 있기 때문이다.</br>
      다시 말해 서브타입의 종류를 캡슐화하고 있는 것이다.</br>
      서브타입 캡슐화가 다형성의 기반이 된다는 것을 알 수 있다.

변경을 캡슐화할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것이다.

[그림 14-13]에서 알 수 있는 것처럼 서브타입 캡슐화와 객체 캡슐화를 적용하는 방법은 다음과 같다.

- 변하는 부분을 분리해서 타입 계층을 만든다
    - 변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화한 후 변하는 부분들이 이 추상 클래스나 인터페이스를 상속받게 만든다.
- 변하지 않는 부분을 일부로 타입 계층을 합성한다
    - 앞에서 구현한 타입 계층을 변하지 않는 부분에 합성한다.</br>
      변하지 않는 부분에서는 변경되는 구체적인 사항에 결합돼서는 안된다.</br>
      의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존하게 만든다.</br>
      이제 변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해서는 알지 못할 것이다. 즉, 변경이 캡슐화된 것이다.</br>
      `Movie` 가 `DiscountPolicy` 를 합성 관계로 연결하고 생성자를 통해 의존성을 해결한 이유가 바로 이 때문이다.

### 03. 일관성 있는 기본 정책 구현하기

<img src="/coherent-cooperation/img/14-22.png" width="500px;" />

**패턴을 찾아라**

애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후, 이 추상화에 변하지 않는 공통적인 책임을 할당해야 한다.

협력을 일관성 있게 만드는 과정은 유사한 기능을 구현하기 위해 반복적으로 적용할 수 있는 협력의 구조를 찾아가는 기나긴 여정이다.</br>
따라서 협력을 일관성 있게 만든다는 것은 유사한 변경을 수용할 수 있는 협력 패턴을 발견하는 것과 동일하다.</br>
