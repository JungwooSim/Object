# 11. 합성과 유연한 설계

상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다.</br>
상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는데 비해 합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.</br>
상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일타임에 해결되지만 합성에서 두 객체 사이의 의존성은 런타임에 해결된다.</br>
상속 관계는 is - a 관계라 부르고 합성 관계는 has-a 관계라 부른다.</br>

합성은 구현에 의존하지 않는다는 점에서 상속과 다르다.</br>
합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.</br>
따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 더 안정적인 코드를 얻을 수 있게 된다.</br>

상속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다.</br>
상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.</br>

### 01. 상속을 합성으로 변경하기

상속을 남용했을 때 직면할 수 있는 세 가지 문제점이 있다.

- 불필요한 인터페이스 상속 문제
    - 자식 클래스에게는 복잡한 부모 클래스의 오퍼레이션이 상속되기 때문에 자식 클래스 인스턴스의 상태가 불안정해지는 문제
- 메서드 오버라이딩의 오작용 문제
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제
- 부모 클래스와 자식 클래스의 동시 수정 문제
    - 부모 클래스와 자식 클래스 사이의 개념적인 결합으로 인해 부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제

합성을 사용하면 상속이 초래하는 세 가지 문제점을 해결할 수 있다.</br>
상속을 합성으로 바꾸는 방법은 매우 간단한데 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.</br>

**메서드 오버라이딩의 오작용 문제: InstrumentedHashSet**

동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드(forwarding method)이라고 부른다.</br>
포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법이다.</br>

### 02. 상속으로 인한 조합의 폭발적인 증가

상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다.</br>
가장 일반적인 상황은 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우다.</br>
일반적으로 다음과 같은 두 가지 문제점이 발생한다.
- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
- 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.

합성을 사용하면 상속으로 인해 발생하는 클래스의 증가와 중복 코드 문제를 간단하게 해결할 수 있다.

**기본 정책에 세금 정책 조합하기** (여기서 정책은 책에서 임시로 설계 한 것 중 한가지)

```
**추상 메서드와 훅 메서드**
개방 - 폐쇄 원칙을 만족하는 설계를 만들 수 있는 한 가지 방법은 부모 클래스에 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다.
자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서 정의한 플로우에 개입할 수 있게 된다.

추상 메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 한다는 것이다.
이는 자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 상속 계층 전반에 걸쳐 중복 코드가 존재하게 될 것이다.
이를 해결하는 방법은 메서드에 기본 구현을 제공하는 것이다. 이처럼 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는
메서드를 훅 메서드(hook method)라고 부른다.
```

<img src="/composition-supple_design/img/11-3.png" width="500px;" />

**기본 정책에 기본 요금 할인 정책 조합하기**

<img src="/composition-supple_design/img/11-4.png" width="500px;" />

위 UML에서 만약에 사로은 할인 정책이 추가하게 되면,

<img src="/composition-supple_design/img/11-5.png" width="500px;" />

[그림11.5] 를 보면 우선 복잡해보인다.</br>
하지만 복잡한 문제보다 더 큰 문제는 새로운 정책을 추가하기가 어렵다.</br>
현재의 설계에 새로운 정책을 추가하기 위해서는 불필요하게 많은 수의 클래스를 상속 계층안에 추가해야 한다.</br>

<img src="/composition-supple_design/img/11-6.png" width="500px;" />

[그림11.6]은 새로운 기본 정책을 추가한 결과를 다이어그램으로 표현한 것이다.</br>
그림에서 짙음 음영으로 표현한 클래스가 새로 추가된 클래스로서 고정 요금제 하나를 추가하기 위해 5개의 새로운 클래스를 추가 했다는 것을 알 수 있다.</br>

상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 **클래스 폭발(class explosion)** 문제 또는 **조합의 폭발(combinationl explosion)** 문제라고 부른다.</br>
이 문제를 해결할 수 있는 최선의 방법은 상속을 포기하는 것이다.</br>

### 03. 합성 관계로 변경하기

상속 관계는 컴파일 타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.</br>
따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하면 모든 조합 가능한 경우별로 클래스를 추가해야 한다.</br>
이것이 바로 핸드폰 과금 시스템의 설계 과정에서 직면했던 클래스 폭발 문제다.</br>
합성은 컴파일타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.</br>
합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체에 관계를 변경할 수 있다.</br>

**기본 정책 합성하기**

다양한 종류의 객체와 협력하기 위해 합성 관계를 사용하는 경우에는 합성하는 객체의 타입을 인터페이스나 추상 클래스로 선언하고 의존성 주입을 사용해 런타임에 필요한 객체를 설정할 수 있도록 구현하는 것이 일반적이다.

<img src="/composition-supple_design/img/11-7.png" width="500px;" />

**부가 정책 적용하기**

<img src="/composition-supple_design/img/11-11.png" width="500px;" />

### 04. 믹스인(mixin)

믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다.</br>
합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.</br>
믹스인과 상속과 비슷하다고 생각할 수 있지만 다르다.</br>
상속은 결과로 부모 클래스의 코드를 재사용할 수 있기는 하지만 상속의 진정한 목적은 자신 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것이다.</br>
반면 믹스인은 말 그대로 코드를 다른 코드 안에 섞어 넣기 위한 방법이다.</br>
