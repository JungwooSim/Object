# 04. 설계 품질과 트레이드 오프

설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다.<br>
훌륭한 설계란 합리적인 비용안에서 수용할 수 있는 구조를 만드는 것이다.<br>
적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도 가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.<br>
결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다.<br>
객체의 상태가 아니라 행동의 초점에 맞추는 것이다.<br>

### 01. 데이터 중심의 영화 예매 시스템

두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.<br>
첫 번째 방법은 상태를 분할의 중심축으로 삼는 방법이고, 두 번째 방법은 책임을 분할의 중심축으로 삼는 방법이다.<br>
앞으로 '상태'와 '데이터'를 동일한 의미로 사용한다.<br>
<br>
데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는데 필요한 오퍼레이션을 정의한다.<br>
책임 중심의 관점에서는 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.<br>
훌륭한 객체지향 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다. 이유는 변경과 관련이 있다.<br>
객체의 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다.<br>
상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.<br>
결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 된다.<br>
따라서 데이터에 초점을 맞추는 설계는 변경에 취약할 수 밖에 없다.<br>
객체의 책임은 인터페이스에 속한다.<br>
객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.<br>
따라서 책임에 초점을 맞추면 상대적으로 변경에 안정적인 설계를 얻을 수 있게 된다.<br>

**데이터를 준비하자**

데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다.<br>
책임 중심의 설계가 '책임이 무엇인가'를 묻는 것으로 시작한다면 데이터 중심의 설계는 객체가 내부에 저장해야 하는 '데이터가 무엇인가'를 묻는 것으로 시작한다.<br>

데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다.<br>
이 객체가 포함해야 하는 데이터는 무엇인가?<br>
객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 데이터 중심의 설계에 매몰돼 있을 확률이 높다.<br>

**영화를 예매하자**

### 02. 설계 트레이드 오프

데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화, 응집도, 결합도를 사용한다.<br.
본격적으로 두 가지 방법을 비교하기 전에 세 가지 품질 척도의 의미를 살펴보자.<br.

**캡슐화**

변경될 가능성이 높은 부분을 **구현**이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.<br>
객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.<br>
객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화 하는 것이다.<br>
설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.<br>
정리하면 **캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.**<br>

**응집도와 결합도**

응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.<br>
객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.<br>
결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.<br>
객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.<br>
응집도와 결합도의 의미를 이해하기 위한 첫걸음은 두 개념 모두 설계와 관련 있다는 사실을 이해하는 것이다.<br>
일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.<br>
변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.<br>
결합도 역시 변경의 관점에서 설명할 수 있다.<br>
결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.<br>
결합도가 높아도 상관 없는 경우도 있다.<br>

일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제도 되지 않는다.<br>
캡슐화의 정도가 응집도와 결합도에 영향을 미친다는 사실을 강조하고 싶다.<br>
캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.<br>
캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 모듈 사이의 결합도는 높아진다.<br>
따라서 응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상시키기 위해 노력해야 한다.<br>

### 03. 데이터 중심의 영화 예매 시스템의 문제점

기능적인 측면에서만 놓고 보면 데이터 중심 설계는 책임 중심 설계와 완전 동일하다.<br>
하지만 설계 관점에서는 완전히 다르다.<br>

데이터 중심 설계는 아래와 같은 문제점을 가지고 있다.<br>

- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

**캡슐화 위반**

설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다.<br>
객체가 사용될 문맥을 추측할 수밖에 없는 경우 개발자는 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것이다.<br>
접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략(design-by-guessing strategy)라고 부른다.<br>
이 전략은 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행 한다.<br>

**높은 결합도**

데이터 중심 설계는 객체의 캡슐화를 약화시키기 때문에 클라이언트가 객체의 구현에 강하게 결합된다.<br>
또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다는 것이다.<br>
이 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수 밖에 없다.<br>

<img src="/design_quality-trade_off/img/4-4.png" width="500px;" />

**낮은 응집도**

서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.<br>

낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다.<br>

- 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.
- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
  응집도가 낮을 경우 다른 모듈에 위치해야 할 책임의 일부가 엉뚱한 곳에 위치하기 때문이다.

```
단일 책임 원칙(Single Responsibility Principle, SRP)
로버트 마틴은 모듈의 응집도가 변경과 연관이 있다는 사실을 강조하기 위해 단일 책임 원칙이라는 설계 원칙을 제시했다.
클래스는 단 한가지의 변경 이유만 가져야 한다는 것이다.
```

### 04. 자율적인 객체를 향해

**캡슐화를 지켜라**

캡슐화는 설계의 제1원리다. 데이터가 중심의 설계가 낮은 응집도와 높은 결홥도라는 문제가 된 근본적인 원인은 캡슐화의 원칙을 위반했기 때문이다.<br>
객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.<br>
여기서 말하는 메서드는 단순히 속성 하나의 값을 반환하거나 변경하는 접근자나 수정자를 의미하는 것은 아니다.<br>
객체에게 의미 있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다.<br>
속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡술화를 위반하는 것이다.<br>

**스스로 자신의 데이터를 책임지는 객체**

우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다.<br>
객체는 단순히 데이터 제공자가 아니다.<br>
객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.<br>
따라서 객체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?"라는 질문은 다음과 같은 두 개의 개별적인 질문으로 분리해야 한다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

두 질문을 조합하면 객체의 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다.

<img src="/design_quality-trade_off/img/4-5.png" width="500px;" />

### 05. 하지만 여전히 부족하다

**캡슐화 위반**

```
캡슐화는 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다.
내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류일 뿐이다.
설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다.
```

**높은 결합도**

**낮은 응집도**

하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 한다는 것은 설계의 응집도가 낮다는 증거다.<br>
응집도가 낮은 이유는 캡슐화를 위반했기 때문이다.<br>

### 06. 데이터 중심 설계의 문제점

데이터 중심 설계가 변경에 취약한 이유는 두 가지다.
- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

**데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다**

데이터 주도 설계는 시작하는 처음부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 한다.<br>
데이터 중심 설계 방식은 익숙한 개발자들은 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다.<br>
이것은 상태와 행동을 하나의 단위로 캡슐화하는 객체지향 패러다임에 반하는 것이다. ← 이것이 첫 번째 실패한 이유다.<br>

데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다.<br>
결과적으로 객체의 인터페이스는 구현을 캡슐화하는데 실패하고 코드는 변경에 취약해 진다. ← 이것이 두 번째 설계가 실패한 이유다.<br>

**데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다**

올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.<br>
중요한 것은 객체가 다른 객체와 협력하는 방법이다.<br>
데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다.<br>
객체의 인터페이스에 구현이 노출돼 있었기 때문에 협력이 구현 세부사항에 종속돼 있고 그에 따라 객체의 내부 구현이 변경됐을 때 협력하는 객체 모두가 영향을 받을 수 밖에 없었던 것이다.<br>
